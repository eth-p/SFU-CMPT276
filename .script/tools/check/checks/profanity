#!/usr/bin/env node
// Copyright (C) 2019 Ethan Pini <epini@sfu.ca>
// MIT License
// ---------------------------------------------------------------------------------------------------------------------
// check: profanity
// Check the project source code for any profanity.
// ---------------------------------------------------------------------------------------------------------------------
const badwords   = require('bad-words');
const fs         = require('fs-extra');
const micromatch = require('micromatch');
const path       = require('path');
const readdirp   = require('readdirp');
// ---------------------------------------------------------------------------------------------------------------------
const ROOT        = path.resolve(__dirname, '../../../../');
const PROJECT     = require(path.resolve(ROOT, '.script/build/project.json'));
const PROFANITY   = new badwords();
const FILTERS     = Object.values(PROJECT.modules).map(x => x.sources).map(x => ({
	include: x.filter(x => !x.startsWith('!')).sort(),
	exclude: x.filter(x => x.startsWith('!')).map(x => x.substring(1)).sort()
}));
// ---------------------------------------------------------------------------------------------------------------------

/**
 * Checks a file for profanity.
 *
 * @param filepath {String} The path to the file.
 * @returns {Promise<bool|string>} True if the function is clean, a string otherwise.
 */
function checkFile(filepath) {
	return new Promise((resolve, reject) => {
		let stream = fs.createReadStream(filepath, {encoding: 'utf-8'});
		let cache  = '';

		stream.on('data', (chunk) => {
			if (PROFANITY.isProfane(cache + chunk)) {
				stream.close();
				return resolve(filepath);
			}

			cache = chunk;
		});

		stream.on('end', () => {resolve(true)});
	});
}

// ---------------------------------------------------------------------------------------------------------------------

let mmopts = {basename: true, dot: true};
let files  = readdirp({root: ROOT, fileFilter: ['!.git', '!.DS_Store', '!node_modules']});
let checks = [];

files.on('data', (data) => {
	// Filtering.
	let fpath = `/${data.path}`;
	let fok   = false;

	for (let filters of FILTERS) {
		if (!micromatch.any(fpath, filters.include, mmopts)) continue;
		if (micromatch.any(fpath, filters.exclude, mmopts)) continue;
		fok = true;
		break;
	}

	if (!fok) return;

	// Processing.
	checks.push(checkFile(path.join(ROOT, fpath)));
});

files.on('end', () => {
	Promise.all(checks).then((results) => {
		let failed = false;

		for (let fail of results.filter(x => x !== true)) {
			console.error(`${fail} contains profanity`);
			failed = true;
		}

		process.exit(failed ? 1 : 0);
	});

});
